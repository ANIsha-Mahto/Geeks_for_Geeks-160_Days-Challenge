class LRUCache {
  public:
    int capacity;
    list<int>lruList;
    unordered_map<int, pair<int, list<int>::iterator>>cache;
    LRUCache(int cap) {
        capacity=cap;
        
    }
    int get(int key) {
        if(cache.find(key)==cache.end()){
             return -1;
        }
        lruList.erase(cache[key].second);
        lruList.push_front(key);
        cache[key].second=lruList.begin();
        return cache[key].first;
        
    }
    void put(int key, int value) {
        if(cache.find(key)!=cache.end()){
            lruList.erase(cache[key].second);
        }
        else if(lruList.size()==capacity){
            int lruKey=lruList.back();
            lruList.pop_back();
            cache.erase(lruKey);
        }
        lruList.push_front(key);
        cache[key]={value,lruList.begin()};
    }
};
